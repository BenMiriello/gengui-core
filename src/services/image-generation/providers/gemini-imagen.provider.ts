import { eq } from 'drizzle-orm';
import { db } from '../../../config/database.js';
import { env } from '../../../config/env.js';
import { media } from '../../../models/schema.js';
import { logger } from '../../../utils/logger.js';
import { redisStreams } from '../../redis-streams.js';
import { s3 } from '../../s3.js';
import type { ImageGenerationProvider } from '../provider.interface.js';
import type { DimensionWhitelist, GenerationInput } from '../types.js';

// Dynamic import: @google/genai is ESM-only, causes TypeScript errors with static import in CommonJS.
// Could use static import if we converted core to ESM, but not worth it just for this.
let genAI: Awaited<ReturnType<typeof getGeminiClient>> | null = null;

async function getGeminiClient() {
  const { GoogleGenAI } = await import('@google/genai');
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) return null;
  return new GoogleGenAI({ apiKey });
}

async function ensureGenAI() {
  if (!genAI) {
    genAI = await getGeminiClient();
  }
  return genAI;
}

// Gemini Imagen 3 supported dimensions
const SUPPORTED_DIMENSIONS: Array<[number, number]> = [
  [1024, 1024], // 1:1
  [1408, 768], // 16:9 landscape
  [768, 1408], // 9:16 portrait
  [1280, 896], // 4:3 landscape
  [896, 1280], // 3:4 portrait
];

class GeminiImagenProvider implements ImageGenerationProvider {
  readonly name = 'gemini' as const;

  isEnabled(): boolean {
    return (
      env.IMAGE_INFERENCE_PROVIDER === 'gemini' && !!process.env.GEMINI_API_KEY
    );
  }

  async submitJob(input: GenerationInput): Promise<void> {
    if (!this.isEnabled()) {
      throw new Error('Gemini Imagen provider is not enabled');
    }

    // Fire and forget - process asynchronously
    this.processGeneration(input).catch((error) => {
      logger.error(
        { error, mediaId: input.mediaId },
        'Gemini Imagen generation failed',
      );
    });
  }

  private async processGeneration(input: GenerationInput): Promise<void> {
    try {
      // Update status to processing
      await db
        .update(media)
        .set({ status: 'processing', updatedAt: new Date() })
        .where(eq(media.id, input.mediaId));

      // Broadcast status update
      await redisStreams.add('job:status:stream', {
        mediaId: input.mediaId,
        status: 'processing',
      });

      // Map dimensions to nearest supported aspect ratio
      const [width, height] = this.mapToNearestDimensions(
        input.width,
        input.height,
      );

      logger.info(
        {
          mediaId: input.mediaId,
          prompt: input.prompt,
          requestedDimensions: `${input.width}x${input.height}`,
          mappedDimensions: `${width}x${height}`,
        },
        'Generating image with Gemini Imagen',
      );

      // Generate image via Gemini Imagen API
      const aspectRatio = this.getAspectRatio(width, height);

      const client = await ensureGenAI();
      if (!client) {
        throw new Error('Gemini client not initialized');
      }

      const response = await client.models.generateImages({
        model: 'imagen-4.0-generate-001',
        prompt: input.prompt,
        config: {
          numberOfImages: 1,
          aspectRatio,
        },
      });

      if (!response.generatedImages || response.generatedImages.length === 0) {
        throw new Error('No images generated by Gemini Imagen');
      }

      // Convert base64 to buffer
      const image = response.generatedImages[0].image;
      if (!image?.imageBytes) {
        throw new Error('No image data returned from Gemini Imagen');
      }
      const imageBytes = image.imageBytes;
      const imageBuffer = Buffer.from(imageBytes, 'base64');

      // Upload to S3
      const s3Key = `users/${input.userId}/media/${input.mediaId}.png`;
      await s3.uploadBuffer(imageBuffer, s3Key, 'image/png');

      // Update DB to completed
      await db
        .update(media)
        .set({
          status: 'completed',
          s3Key,
          width,
          height,
          updatedAt: new Date(),
        })
        .where(eq(media.id, input.mediaId));

      // Broadcast completion
      await redisStreams.add('job:status:stream', {
        mediaId: input.mediaId,
        status: 'completed',
        s3Key,
      });

      logger.info(
        { mediaId: input.mediaId, s3Key },
        'Gemini Imagen generation completed',
      );
    } catch (error: any) {
      logger.error(
        { error, mediaId: input.mediaId },
        'Gemini Imagen generation failed',
      );

      const errorMessage = error?.message || 'Unknown error';

      // Update DB to failed
      await db
        .update(media)
        .set({
          status: 'failed',
          error: errorMessage,
          updatedAt: new Date(),
        })
        .where(eq(media.id, input.mediaId));

      // Broadcast failure
      await redisStreams.add('job:status:stream', {
        mediaId: input.mediaId,
        status: 'failed',
        error: errorMessage,
      });
    }
  }

  getSupportedDimensions(): DimensionWhitelist {
    return SUPPORTED_DIMENSIONS.map(([width, height]) => ({ width, height }));
  }

  validateDimensions(width: number, height: number): boolean {
    // Allow dimensions with compatible aspect ratios, not just exact matches
    // This allows the mapping logic to convert to nearest supported size
    const requestedRatio = width / height;
    return SUPPORTED_DIMENSIONS.some(([w, h]) => {
      const supportedRatio = w / h;
      return Math.abs(supportedRatio - requestedRatio) < 0.1;
    });
  }

  supportsReferenceImages(): boolean {
    return false;
  }

  /**
   * Map requested dimensions to nearest supported Gemini Imagen dimensions
   */
  private mapToNearestDimensions(
    width: number,
    height: number,
  ): [number, number] {
    // Check if exact match exists
    const exactMatch = SUPPORTED_DIMENSIONS.find(
      ([w, h]) => w === width && h === height,
    );
    if (exactMatch) {
      return exactMatch;
    }

    // Find nearest by aspect ratio
    const requestedRatio = width / height;
    let nearest = SUPPORTED_DIMENSIONS[0];
    let minDiff = Math.abs(nearest[0] / nearest[1] - requestedRatio);

    for (const dims of SUPPORTED_DIMENSIONS) {
      const ratio = dims[0] / dims[1];
      const diff = Math.abs(ratio - requestedRatio);
      if (diff < minDiff) {
        minDiff = diff;
        nearest = dims;
      }
    }

    logger.warn(
      {
        requested: `${width}x${height}`,
        mapped: `${nearest[0]}x${nearest[1]}`,
      },
      'Mapped to nearest supported Gemini Imagen dimensions',
    );

    return nearest;
  }

  /**
   * Get aspect ratio string for Gemini API
   */
  private getAspectRatio(width: number, height: number): string {
    const ratio = width / height;

    if (Math.abs(ratio - 1) < 0.01) return '1:1';
    if (Math.abs(ratio - 1.833) < 0.01) return '16:9';
    if (Math.abs(ratio - 0.545) < 0.01) return '9:16';
    if (Math.abs(ratio - 1.429) < 0.01) return '4:3';
    if (Math.abs(ratio - 0.7) < 0.01) return '3:4';

    // Default to 1:1
    logger.warn(
      { width, height, ratio },
      'Unknown aspect ratio, defaulting to 1:1',
    );
    return '1:1';
  }
}

export const geminiImagenProvider = new GeminiImagenProvider();
